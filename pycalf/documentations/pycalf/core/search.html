<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pycalf.core.search API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pycalf.core.search</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sys
import re
import logging
import tempfile
import concurrent
import concurrent.futures
import multiprocessing

import pandas as pd
from shutil import which

import pyhmmer
import tqdm

from Bio.SeqFeature import SeqFeature, FeatureLocation

from pycalf.utils import log
from pycalf.core.Hmm import Hmm
from pycalf.core.Sequences  import Sequences, Seq , Hit

from Bio.SeqRecord import SeqRecord

logging.basicConfig(
    format=&#34;%(asctime)s [%(threadName)-12.12s] [%(levelname)-5.5s]  %(message)s&#34;,
    level=logging.INFO,
    handlers=[]
)

def _search_calcyanin(fasta:str, 
                    src:str,
                    glyx3_hmm:pyhmmer.plan7.HMM, 
                    gly1_hmm:pyhmmer.plan7.HMM, 
                    gly2_hmm:pyhmmer.plan7.HMM, 
                    gly3_hmm:pyhmmer.plan7.HMM,
                    nter_fa:str, 
                    glyx3_evalue_threshold:float=1e-30,
                    glyx3_coverage_threshold:float=0.5,
                    ):
    &#34;&#34;&#34;Find calcyanin within a fasta file using several HMM profiles and &#39;database&#39; of known N-ter.
    
    Args:
        fasta (str): Path to a fasta file - required.
        src (str): will be attached to calcyanin. Useful when searching across multiple files.  
        glyx3_hmm (pyhmmer.plan7.HMM):  Glyx3 HMM profile - required
        gly1_hmm (pyhmmer.plan7.HMM): Gly1 HMM profile - required
        gly2_hmm (pyhmmer.plan7.HMM): Gly2 HMM profile - required
        gly3_hmm (pyhmmer.plan7.HMM): Gly3 HMM profile - required
        nter_fa (str): Path to fasta file containing known N-ter sequences - required

        glyx3_evalue_threshold (float): E-value threshold for glyx3 
        glyx3_coverage_threshold (float): Coverage theshold for glyx3

    Raises:
        TypeError if one sequence is not an instance of pyhmmer.easel.DigitalSequence.

    Return:
        Hmm object
    &#34;&#34;&#34;
    # Setup sequences - Parse fasta into Sequences object 
    sequences = Sequences(fasta,src=src)

    # Search sequences against GlyX3 profile
    glyx3_sequences = sequences.hmmsearch([glyx3_hmm])
    for seq in glyx3_sequences.sequences:
        hit_below_evalue_threshold = [ h for h in seq.hits if h.score &lt; glyx3_evalue_threshold]     
        if hit_below_evalue_threshold:          
            start_glyx3 = min([h.start_location for h in hit_below_evalue_threshold])
            end_glyx3 = max([h.stop_location for h in hit_below_evalue_threshold])
            scores = [h.score for h in hit_below_evalue_threshold]
            hmm_profile_len = [h.target_len for h in hit_below_evalue_threshold][0]
            coverage_on_glyx3 = (end_glyx3-start_glyx3)/hmm_profile_len #glyx3_easel_hmm[0].M
            mean_identity = sum([h.identity for h in hit_below_evalue_threshold])/len(hit_below_evalue_threshold)
            f = SeqFeature(
                FeatureLocation(
                    start_glyx3, 
                    end_glyx3
                    ),
                id=&#34;GlyX3&#34;,
                type=&#34;domain&#34;, 
                qualifiers={
                    &#34;n_hits&#34;:len(hit_below_evalue_threshold),
                    &#34;score&#34;:min(scores),
                    &#34;src&#34;:&#34;GlyX3_HMM_Profile&#34;,
                    &#34;src_len&#34;:hmm_profile_len,
                    &#34;identity&#34;:mean_identity
                })
            # Clean sequence hits list for next step.
            seq.hits=[]
            seq.features.append( f )
    
    glyx3_sequences.sequences = [s for s in glyx3_sequences.sequences if s.features] 
    
    # Search GlyZip profiles

    glzips_easel_hmm = [gly1_hmm,gly2_hmm,gly3_hmm]
    glyx3_sequences = glyx3_sequences.hmmsearch(glzips_easel_hmm)
    
    for seq in glyx3_sequences.sequences:
        seq.per_residue_annotation()
        current = Hit()
        features = []
        features_len = []
        fraglen = 0
        for res,hit in seq.res.items():   
            if hit:
                if hit[0].score &lt; 1:        
                    if current.hid == hit[0].hid:
                        fraglen += 1
                        continue    
                    else:
                        if current.hid:                            
                            features.append(current)
                            features_len.append(fraglen)
                        current = hit[0]           
                        fraglen=0                               

            else:
                if current.hid:
                    features.append(current)
                    features_len.append(fraglen)
                current = Hit()
                fraglen=0
        
        glyzip_coverage_threshold = 0.8
        feat = [ f for f,fl in zip(features,features_len)  if fl/f.target_len &gt; glyzip_coverage_threshold ]
        seq.hits = feat
    
        for valid_glyzip_hit in seq.hits:
            f = SeqFeature(
                FeatureLocation(
                    valid_glyzip_hit.start_location, 
                    valid_glyzip_hit.stop_location
                    ),
                id=valid_glyzip_hit.hid,
                type=&#34;domain&#34;, 
                qualifiers={
                    &#34;n_hits&#34;:1,
                    &#34;score&#34;:valid_glyzip_hit.score,
                    &#34;src&#34;:&#34;{}_HMM_Profile&#34;.format(valid_glyzip_hit.hid),
                    &#34;src_len&#34;:valid_glyzip_hit.target_len,
                    &#34;identity&#34;:valid_glyzip_hit.identity
                })
            seq.features.append( f )
        seq.hits = []


    # Search N-ter
    nter_evalue_t = 1e-4
    nter_cov_t = 0.7
    glyx3_sequences.blastp(nter_fa)
    for seq in glyx3_sequences.sequences:
        for valid_nter_hit in seq.hits:
            if valid_nter_hit.score &lt; nter_evalue_t and valid_nter_hit.coverage &gt;= nter_cov_t:
                f = SeqFeature(
                    FeatureLocation(
                        valid_nter_hit.start_location, 
                        valid_nter_hit.stop_location
                        ),
                    id=&#34;N-ter&#34;,
                    type=&#34;domain&#34;, 
                    qualifiers={
                        &#34;n_hits&#34;:len(seq.hits),
                        &#34;score&#34;:valid_nter_hit.score,
                        &#34;src&#34;:valid_nter_hit.hid,
                        &#34;src_len&#34;:valid_nter_hit.target_len,
                        &#34;identity&#34;:valid_nter_hit.identity
                    })
                seq.features.append( f )
                # because we keep only the best one - aka the nearest neighboor.
                break
        seq.hits = []
    return glyx3_sequences

def _search_calcyanin_mt(args):    
    &#34;&#34;&#34;helper function to run search_calcyanin() from concurrent futures.&#34;&#34;&#34;
    return _search_calcyanin(*args)

def _search_calcyanin_concurrent(fastas:list,  
                    srcs:list,                                
                    glyx3_hmm:Hmm, 
                    gly1_hmm:Hmm, 
                    gly2_hmm:Hmm, 
                    gly3_hmm:Hmm,
                    nter_fa:str, 
                    glyx3_evalue_threshold:float=1e-30,
                    glyx3_coverage_threshold:float=0.5):
    &#34;&#34;&#34;Wrapper to run multiple file at once with the function _search_calcyanin.
    
    Args:
        fastas (list): list of fasta file - required.
        srcs (list): list of flag that will be attached to calcyanin. Useful when searching across multiple files.  
        glyx3_hmm (pyhmmer.plan7.HMM):  Glyx3 HMM profile - required
        gly1_hmm (pyhmmer.plan7.HMM): Gly1 HMM profile - required
        gly2_hmm (pyhmmer.plan7.HMM): Gly2 HMM profile - required
        gly3_hmm (pyhmmer.plan7.HMM): Gly3 HMM profile - required
        nter_fa (str): Path to fasta file containing known N-ter sequences - required

        glyx3_evalue_threshold (float): E-value threshold for glyx3 
        glyx3_coverage_threshold (float): Coverage theshold for glyx3

    Raises:
        AssertionError if one hmm is not an instance of Hmm.

    Return:
        Hmm object
    &#34;&#34;&#34;                 
                       
    assert isinstance(glyx3_hmm,Hmm)
    assert isinstance(gly1_hmm, Hmm)
    assert isinstance(gly2_hmm, Hmm)
    assert isinstance(gly3_hmm, Hmm)
    assert len(srcs)==len(fastas)

    pools = []
    l = []
    for fasta_file,src in zip(fastas,srcs):
        pools.append(
            (fasta_file,
            src,
            glyx3_hmm.hmm,
            gly1_hmm.hmm,
            gly2_hmm.hmm,
            gly3_hmm.hmm,
            nter_fa,
            glyx3_evalue_threshold,
            glyx3_coverage_threshold,
            )
        )
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=multiprocessing.cpu_count()-1) as executor:
        l+=list(tqdm.tqdm(executor.map(_search_calcyanin_mt, pools), total=len(pools)))
        
    calcyanin_sequences = Sequences()
    for e in l:
        calcyanin_sequences.sequences += e.sequences

    return calcyanin_sequences

def __modifyline__(string,val):
    &#34;&#34;&#34;Modify the weight of Glycine residue&#34;&#34;&#34;
    liste = string.split()
    if len(liste) &gt;= 21:
        liste[6] = str(val*float(liste[6]))
    elif len(liste) == 20:
        liste[5] = str(val*float(liste[5]))
    else : 
        return string
    return(&#34;  &#34;.join(liste))

def increase_glycine_weight(hmm,pc):
    &#34;&#34;&#34;Increase weight of Glycine within a hmm profile.
    
    Args:
        hmm (Hmm): Hmm object.
        pc (float): weigth factor.
    Raises:
        None
    Return:
        weighted pyhmmer.plan7.HMM
    &#34;&#34;&#34;
    # dump hmm as tmpfile
    tmp = tempfile.NamedTemporaryFile(mode=&#34;wb&#34;)
    hmm.hmm.write(tmp,binary=False)
    tmp.flush()
    # update lines 
    start =  True
    val = 1 - pc
    l = []
    with open(tmp.name,&#34;r&#34;) as fin:
        for line in fin:
            if start:
                res = re.match(&#34;.*COMPO.*&#34;,line)
                if res:
                    start = False
                    newline = __modifyline__(line,val)+&#34;\n&#34;
                else:
                    newline = line
            else:
                    newline = __modifyline__(line,val)+&#34;\n&#34;
            l.append(newline)    
    tmp = tempfile.NamedTemporaryFile(mode=&#34;w&#34;)
    with open(tmp.name,&#39;wb&#39;) as fout:
        for _ in l:
            tmp.write(_)
    tmp.flush()
    
    with pyhmmer.plan7.HMMFile( tmp.name ) as hmm_file:
        hmm = hmm_file.read()
    return hmm

def update_hmm(l_seq,hmm):
    &#34;&#34;&#34;Update Hmm by aligning sequences against it
    
    Args:
        l_seq (list): List of Seq object.
        hmm (Hmm): Hmm object.
    Raises:
        None
    Return:
        Updated Hmm object.
    &#34;&#34;&#34;    
    l_digital_seq = [ s.digitize() for s in l_seq ]
    new_hmm = hmm.hmmalign( l_digital_seq )
    new_hmm.hmm = increase_glycine_weight( new_hmm,0.2 )
    return new_hmm

def search(
        fastas:list, 
        srcs:list,
        glyx3:Hmm, 
        gly1:Hmm, 
        gly2:Hmm, 
        gly3:Hmm,
        nter_fa:str, 
        glyx3_evalue_threshold:float=1e-30,
        glyx3_coverage_threshold:float=0.5,
        is_iterative=True): 
    &#34;&#34;&#34;Search for calcyanin within one or more fasta files using several HMM profiles and &#39;database&#39; of known N-ter.

    If is_iterative is set , then HMMs profiles and N-ter database is updated at each iteration with new calcyanin if any.
    it&#39;s first search for calcyanin based on the Glycine zipper repeat (aka Glyx3). Then each glycine zipper is searched using 
    a specific HMM profile. Finally, sequences with a Glyx3 are searched against a database of known N-ter using blastp. 
    
    Args:
        fastas (list): list of fasta file - required.
        srcs (list): list of flag that will be attached to calcyanin. Useful when searching across multiple files. 
        glyx3_hmm (pyhmmer.plan7.HMM):  Glyx3 HMM profile - required
        gly1_hmm (pyhmmer.plan7.HMM): Gly1 HMM profile - required
        gly2_hmm (pyhmmer.plan7.HMM): Gly2 HMM profile - required
        gly3_hmm (pyhmmer.plan7.HMM): Gly3 HMM profile - required
        nter_fa (str): Path to fasta file containing known N-ter sequences - required
        glyx3_evalue_threshold (float): E-value threshold for glyx3 
        glyx3_coverage_threshold (float): Coverage theshold for glyx3
        is_iterative (bool): If set iterative 
    Raises:
        TypeError if one sequence is not an instance of pyhmmer.easel.DigitalSequence.
    Return:
        A tuple containing calcyanins as Sequences object, Glyx3, Gly1, Gly2 and Gly3 as Hmm objects.
    &#34;&#34;&#34;

    
    not_converged = True
    lseqs = []
    logging.info(&#34;Iterative : {}&#34;.format(is_iterative))
    max_iteration = 1
    if is_iterative:
        max_iteration=10        
        logging.info(&#34;Max Iteration : {}&#34;.format(max_iteration))
    ite=0
    while not_converged:
        # search calcyanin        
        logging.info(&#34;[iteration {}] |  Search calcyanin&#34;.format(ite))
        calcyanin_sequences = _search_calcyanin_concurrent(fastas, 
                srcs,
                glyx3,
                gly1,
                gly2,
                gly3,
                nter_fa,
                glyx3_evalue_threshold,
                glyx3_coverage_threshold 
            )
        not_converged=False        
        if calcyanin_sequences.sequences:
            #logging.info(&#34; [iteration {}] |  New calcyanin detected.&#34;.format(ite))                    
            for seq in calcyanin_sequences.sequences:
                if seq.id not in lseqs:                          
                    lseqs.append(seq.id)         
                    not_converged=True
        
        if not_converged:
            logging.info(&#34;[iteration {}] | New calcyanin found ! :)&#34;.format(ite))        
            logging.info(&#34;[iteration {}] |  Updating GlyX3&#34;.format(ite))
            glyx3features = calcyanin_sequences.get_feature(&#34;GlyX3&#34;)
            if glyx3features:  
                glyx3 = update_hmm(glyx3features,glyx3)

            logging.info(&#34;[iteration {}] |  Updating Gly1&#34;.format(ite))
            gly1features = calcyanin_sequences.get_feature(&#34;Gly1&#34;)        
            if gly1features:
                gly1 = update_hmm(gly1features,gly1)
  
            logging.info(&#34;[iteration {}] |  Updating Gly2&#34;.format(ite))
            gly2features = calcyanin_sequences.get_feature(&#34;Gly2&#34;)        
            if gly2features:
                gly2 = update_hmm(gly2features,gly2)

            logging.info(&#34;[iteration {}] |  Updating Gly3&#34;.format(ite))
            gly3features = calcyanin_sequences.get_feature(&#34;Gly3&#34;)        
            if gly3features:
                gly3 = update_hmm(gly1features,gly3)
        
            ite += 1
            if ite == max_iteration:
                logging.warning(&#34;Max iteration reached.&#34;)
                not_converged=False
        else:
            logging.info(&#34;[iteration {}] | No new calcyanin detected.&#34;.format(ite))
            logging.info(&#34;[iteration {}] | Stop.&#34;.format(ite))
            
    return calcyanin_sequences, glyx3 , gly1, gly2, gly3    

            
def make_nter_fasta(nterdb):   
    &#34;&#34;&#34;parse the nterdb file to dictionnary&#34;&#34;&#34;
    nter_dict={} 
    with open(nterdb) as db:
        for line in db.readlines():
            nter, strain, seq = line.strip().split()
            nter_dict[strain] = (nter,seq)
            
    return nter_dict

def decision_tree(nter , cter):
    &#34;&#34;&#34;give a flag to a calcyanin based on its C-ter modular organization and its N-ter.&#34;&#34;&#34;
    if re.search(&#34;Gly1,Gly2,Gly3&#34;,cter):
        if nter in [&#34;CoBaHMA-type&#34;,&#34;Y-type&#34;,&#34;X-type&#34;,&#34;Z-type&#34;]:
            flag = &#34;Calcyanin with known N-ter&#34;
        else:
            flag = &#34;Calcyanin with new N-ter&#34;
    elif re.search(&#34;Gly1,Gly3&#34;,cter) and nter == &#34;Y-type&#34;:
        flag = &#34;Calcyanin with known N-ter&#34;
    elif re.search (&#34;Gly(1|2|3)&#34;,cter):
        if nter in [&#34;CoBaHMA-type&#34;,&#34;Y-type&#34;,&#34;X-type&#34;,&#34;Z-type&#34;]:
            flag = &#34;Atypical Gly region with known N-ter&#34;
        else:
            flag = &#34;Atypical Gly region with new N-ter&#34;
    else:
        flag=&#34;Ancestral gly containing protein&#34;
    return flag

if __name__ == &#34;__main__&#34;:
    
    console = logging.StreamHandler()
    console.setLevel(logging.INFO)
    console.setFormatter(log.CustomFormatter())
    logging.getLogger(&#39;&#39;).addHandler(
        console)
    #f = &#34;/Users/mmillet/harley_databases/tmp/datas/taxids/1126/ncbi_dataset/data/GCA_008757435.1/cds_from_genomic.faa.gz&#34;
    glyx3 = Hmm(&#34;Glyx3&#34;,&#34;../datas/GlyX3.msa.fa&#34;)
    gly1 = Hmm(&#34;Gly1&#34;,&#34;../datas/Gly1.msa.fa&#34;)
    gly2 = Hmm(&#34;Gly2&#34;,&#34;../datas/Gly2.msa.fa&#34;)
    gly3 = Hmm(&#34;Gly3&#34;,&#34;../datas/Gly3.msa.fa&#34;)
    
    nterdb = make_nter_fasta(&#34;../datas/nterdb.ref.tsv&#34;)
    nterfa = tempfile.NamedTemporaryFile(mode=&#34;w+&#34;)
    for sid, nter in nterdb.items():
        nterfa.write(&#34;&gt;{}|{}\n{}\n&#34;.format(nter[0],sid,nter[1]))
    nterfa.flush()
        
    _glyx3_nseq = glyx3.hmm.nseq
    _gly1_nseq = gly1.hmm.nseq
    _gly2_nseq = gly2.hmm.nseq
    _gly3_nseq = gly3.hmm.nseq

    fastas = []
    names = []
    with open(&#34;test.txt&#34;) as stream:
        for line in stream.readlines():
            n,f = line.strip().split()
            fastas.append(f)
            names.append(n)
    logging.info(&#34;Start search.&#34;)
    fastas = [&#34;../test/ncbi_dataset/data/GCF_000307995.1/protein.faa&#34;]# for i in range(0,5)]
    names = [&#34;GCF_000307995&#34;]# for i in range(0,5) ]

    calseq , u_glyx3 , u_gly1, u_gly2 , u_gly3 = search(
        fastas,
        names,
        glyx3,
        gly1,
        gly2,
        gly3,
        nterfa.name,        
        glyx3_evalue_threshold=1e-30,
        is_iterative=False
    )

    #print(calseq.to_feature_table())
    #u_gly1.hmm.write(open(&#34;test.new.hmm&#34;,&#34;wb&#34;))
    logging.info(&#34;# Number of calcyanin detected : {}&#34;.format(len(calseq.sequences)))
    logging.info(&#34;# N_seqs within Glyx3 HMM : {} [+{}]&#34;.format(u_glyx3.hmm.nseq, u_glyx3.hmm.nseq -  _glyx3_nseq))
    logging.info(&#34;# N_seqs within Gly1 HMM : {} [+{}]&#34;.format(u_gly1.hmm.nseq, u_gly1.hmm.nseq - _gly1_nseq))
    logging.info(&#34;# N_seqs within Gly2 HMM : {} [+{}]&#34;.format(u_gly2.hmm.nseq, u_gly2.hmm.nseq - _gly2_nseq))
    logging.info(&#34;# N_seqs within Gly3 HMM : {} [+{}]&#34;.format(u_gly3.hmm.nseq, u_gly3.hmm.nseq - _glyx3_nseq))
    
    logging.info(&#34;Dumping HMMs.&#34;)
    u_glyx3.hmm.write(open(&#34;Glyx3.hmm&#34;,&#34;wb&#34;))
    u_gly1.hmm.write(open(&#34;Gly1.hmm&#34;,&#34;wb&#34;))
    u_gly2.hmm.write(open(&#34;Gly2.hmm&#34;,&#34;wb&#34;))
    u_gly3.hmm.write(open(&#34;Gly3.hmm&#34;,&#34;wb&#34;))
    logging.info(&#34;Dumping MSAs.&#34;)
    u_glyx3.msa.write(open(&#34;Glyx3.msa.fa&#34;,&#34;wb&#34;),format=&#34;afa&#34;)
    u_gly1.msa.write(open(&#34;Gly1.msa.fa&#34;,&#34;wb&#34;),format=&#34;afa&#34;)
    u_gly2.msa.write(open(&#34;Gly2.msa.fa&#34;,&#34;wb&#34;),format=&#34;afa&#34;)
    u_gly3.msa.write(open(&#34;Gly3.msa.fa&#34;,&#34;wb&#34;),format=&#34;afa&#34;)
    logging.info(&#34;Dumping feature table.&#34;)
    features = calseq.to_feature_table()
    features.to_csv(&#34;features.tsv&#34;,sep=&#34;\t&#34;,header=True,index=True)
    logging.info(&#34;Make summary.&#34;)
    summary_datas = []
    for sequence, seq_features_df in features.groupby(&#34;sequence_id&#34;):
        cterom = &#34;,&#34;.join(
                        list(
                            seq_features_df[seq_features_df.feature_id.isin([&#34;Gly1&#34;,&#34;Gly2&#34;,&#34;Gly3&#34;]) ].sort_values(&#34;feature_start&#34;).feature_id
                            )
                )
        nterom = &#34;&#34;.join(set(
            seq_features_df[seq_features_df.feature_id == &#34;N-ter&#34; ].feature_src
        ))
        
            
        summary_datas.append(
            {
                &#34;sequence_accession&#34;:sequence,
                &#34;flag&#34;:decision_tree(nterom.split(&#34;|&#34;)[0],cterom),
                &#34;nter&#34;:nterom.split(&#34;|&#34;)[0],
                &#34;nter_neighbor&#34;: nterom.split(&#34;|&#34;)[1],
                &#34;cter&#34;:cterom,
                &#34;sequence&#34;:str(calseq.get_seq_by_id(sequence).seq)
            }
        )
        pd.DataFrame(summary_datas).set_index(&#34;sequence_accession&#34;).to_csv(sys.stdout,sep=&#34;\t&#34;,index=True,header=True)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pycalf.core.search.decision_tree"><code class="name flex">
<span>def <span class="ident">decision_tree</span></span>(<span>nter, cter)</span>
</code></dt>
<dd>
<div class="desc"><p>give a flag to a calcyanin based on its C-ter modular organization and its N-ter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decision_tree(nter , cter):
    &#34;&#34;&#34;give a flag to a calcyanin based on its C-ter modular organization and its N-ter.&#34;&#34;&#34;
    if re.search(&#34;Gly1,Gly2,Gly3&#34;,cter):
        if nter in [&#34;CoBaHMA-type&#34;,&#34;Y-type&#34;,&#34;X-type&#34;,&#34;Z-type&#34;]:
            flag = &#34;Calcyanin with known N-ter&#34;
        else:
            flag = &#34;Calcyanin with new N-ter&#34;
    elif re.search(&#34;Gly1,Gly3&#34;,cter) and nter == &#34;Y-type&#34;:
        flag = &#34;Calcyanin with known N-ter&#34;
    elif re.search (&#34;Gly(1|2|3)&#34;,cter):
        if nter in [&#34;CoBaHMA-type&#34;,&#34;Y-type&#34;,&#34;X-type&#34;,&#34;Z-type&#34;]:
            flag = &#34;Atypical Gly region with known N-ter&#34;
        else:
            flag = &#34;Atypical Gly region with new N-ter&#34;
    else:
        flag=&#34;Ancestral gly containing protein&#34;
    return flag</code></pre>
</details>
</dd>
<dt id="pycalf.core.search.increase_glycine_weight"><code class="name flex">
<span>def <span class="ident">increase_glycine_weight</span></span>(<span>hmm, pc)</span>
</code></dt>
<dd>
<div class="desc"><p>Increase weight of Glycine within a hmm profile.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hmm</code></strong> :&ensp;<code>Hmm</code></dt>
<dd>Hmm object.</dd>
<dt><strong><code>pc</code></strong> :&ensp;<code>float</code></dt>
<dd>weigth factor.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>None</p>
<h2 id="return">Return</h2>
<p>weighted pyhmmer.plan7.HMM</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def increase_glycine_weight(hmm,pc):
    &#34;&#34;&#34;Increase weight of Glycine within a hmm profile.
    
    Args:
        hmm (Hmm): Hmm object.
        pc (float): weigth factor.
    Raises:
        None
    Return:
        weighted pyhmmer.plan7.HMM
    &#34;&#34;&#34;
    # dump hmm as tmpfile
    tmp = tempfile.NamedTemporaryFile(mode=&#34;wb&#34;)
    hmm.hmm.write(tmp,binary=False)
    tmp.flush()
    # update lines 
    start =  True
    val = 1 - pc
    l = []
    with open(tmp.name,&#34;r&#34;) as fin:
        for line in fin:
            if start:
                res = re.match(&#34;.*COMPO.*&#34;,line)
                if res:
                    start = False
                    newline = __modifyline__(line,val)+&#34;\n&#34;
                else:
                    newline = line
            else:
                    newline = __modifyline__(line,val)+&#34;\n&#34;
            l.append(newline)    
    tmp = tempfile.NamedTemporaryFile(mode=&#34;w&#34;)
    with open(tmp.name,&#39;wb&#39;) as fout:
        for _ in l:
            tmp.write(_)
    tmp.flush()
    
    with pyhmmer.plan7.HMMFile( tmp.name ) as hmm_file:
        hmm = hmm_file.read()
    return hmm</code></pre>
</details>
</dd>
<dt id="pycalf.core.search.make_nter_fasta"><code class="name flex">
<span>def <span class="ident">make_nter_fasta</span></span>(<span>nterdb)</span>
</code></dt>
<dd>
<div class="desc"><p>parse the nterdb file to dictionnary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_nter_fasta(nterdb):   
    &#34;&#34;&#34;parse the nterdb file to dictionnary&#34;&#34;&#34;
    nter_dict={} 
    with open(nterdb) as db:
        for line in db.readlines():
            nter, strain, seq = line.strip().split()
            nter_dict[strain] = (nter,seq)
            
    return nter_dict</code></pre>
</details>
</dd>
<dt id="pycalf.core.search.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>fastas: list, srcs: list, glyx3: <a title="pycalf.core.Hmm.Hmm" href="Hmm.html#pycalf.core.Hmm.Hmm">Hmm</a>, gly1: <a title="pycalf.core.Hmm.Hmm" href="Hmm.html#pycalf.core.Hmm.Hmm">Hmm</a>, gly2: <a title="pycalf.core.Hmm.Hmm" href="Hmm.html#pycalf.core.Hmm.Hmm">Hmm</a>, gly3: <a title="pycalf.core.Hmm.Hmm" href="Hmm.html#pycalf.core.Hmm.Hmm">Hmm</a>, nter_fa: str, glyx3_evalue_threshold: float = 1e-30, glyx3_coverage_threshold: float = 0.5, is_iterative=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Search for calcyanin within one or more fasta files using several HMM profiles and 'database' of known N-ter.</p>
<p>If is_iterative is set , then HMMs profiles and N-ter database is updated at each iteration with new calcyanin if any.
it's first search for calcyanin based on the Glycine zipper repeat (aka Glyx3). Then each glycine zipper is searched using
a specific HMM profile. Finally, sequences with a Glyx3 are searched against a database of known N-ter using blastp. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fastas</code></strong> :&ensp;<code>list</code></dt>
<dd>list of fasta file - required.</dd>
<dt><strong><code>srcs</code></strong> :&ensp;<code>list</code></dt>
<dd>list of flag that will be attached to calcyanin. Useful when searching across multiple files. </dd>
<dt><strong><code>glyx3_hmm</code></strong> :&ensp;<code>pyhmmer.plan7.HMM</code></dt>
<dd>Glyx3 HMM profile - required</dd>
<dt><strong><code>gly1_hmm</code></strong> :&ensp;<code>pyhmmer.plan7.HMM</code></dt>
<dd>Gly1 HMM profile - required</dd>
<dt><strong><code>gly2_hmm</code></strong> :&ensp;<code>pyhmmer.plan7.HMM</code></dt>
<dd>Gly2 HMM profile - required</dd>
<dt><strong><code>gly3_hmm</code></strong> :&ensp;<code>pyhmmer.plan7.HMM</code></dt>
<dd>Gly3 HMM profile - required</dd>
<dt><strong><code>nter_fa</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to fasta file containing known N-ter sequences - required</dd>
<dt><strong><code>glyx3_evalue_threshold</code></strong> :&ensp;<code>float</code></dt>
<dd>E-value threshold for glyx3 </dd>
<dt><strong><code>glyx3_coverage_threshold</code></strong> :&ensp;<code>float</code></dt>
<dd>Coverage theshold for glyx3</dd>
<dt><strong><code>is_iterative</code></strong> :&ensp;<code>bool</code></dt>
<dd>If set iterative </dd>
</dl>
<h2 id="raises">Raises</h2>
<p>TypeError if one sequence is not an instance of pyhmmer.easel.DigitalSequence.</p>
<h2 id="return">Return</h2>
<p>A tuple containing calcyanins as Sequences object, Glyx3, Gly1, Gly2 and Gly3 as Hmm objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search(
        fastas:list, 
        srcs:list,
        glyx3:Hmm, 
        gly1:Hmm, 
        gly2:Hmm, 
        gly3:Hmm,
        nter_fa:str, 
        glyx3_evalue_threshold:float=1e-30,
        glyx3_coverage_threshold:float=0.5,
        is_iterative=True): 
    &#34;&#34;&#34;Search for calcyanin within one or more fasta files using several HMM profiles and &#39;database&#39; of known N-ter.

    If is_iterative is set , then HMMs profiles and N-ter database is updated at each iteration with new calcyanin if any.
    it&#39;s first search for calcyanin based on the Glycine zipper repeat (aka Glyx3). Then each glycine zipper is searched using 
    a specific HMM profile. Finally, sequences with a Glyx3 are searched against a database of known N-ter using blastp. 
    
    Args:
        fastas (list): list of fasta file - required.
        srcs (list): list of flag that will be attached to calcyanin. Useful when searching across multiple files. 
        glyx3_hmm (pyhmmer.plan7.HMM):  Glyx3 HMM profile - required
        gly1_hmm (pyhmmer.plan7.HMM): Gly1 HMM profile - required
        gly2_hmm (pyhmmer.plan7.HMM): Gly2 HMM profile - required
        gly3_hmm (pyhmmer.plan7.HMM): Gly3 HMM profile - required
        nter_fa (str): Path to fasta file containing known N-ter sequences - required
        glyx3_evalue_threshold (float): E-value threshold for glyx3 
        glyx3_coverage_threshold (float): Coverage theshold for glyx3
        is_iterative (bool): If set iterative 
    Raises:
        TypeError if one sequence is not an instance of pyhmmer.easel.DigitalSequence.
    Return:
        A tuple containing calcyanins as Sequences object, Glyx3, Gly1, Gly2 and Gly3 as Hmm objects.
    &#34;&#34;&#34;

    
    not_converged = True
    lseqs = []
    logging.info(&#34;Iterative : {}&#34;.format(is_iterative))
    max_iteration = 1
    if is_iterative:
        max_iteration=10        
        logging.info(&#34;Max Iteration : {}&#34;.format(max_iteration))
    ite=0
    while not_converged:
        # search calcyanin        
        logging.info(&#34;[iteration {}] |  Search calcyanin&#34;.format(ite))
        calcyanin_sequences = _search_calcyanin_concurrent(fastas, 
                srcs,
                glyx3,
                gly1,
                gly2,
                gly3,
                nter_fa,
                glyx3_evalue_threshold,
                glyx3_coverage_threshold 
            )
        not_converged=False        
        if calcyanin_sequences.sequences:
            #logging.info(&#34; [iteration {}] |  New calcyanin detected.&#34;.format(ite))                    
            for seq in calcyanin_sequences.sequences:
                if seq.id not in lseqs:                          
                    lseqs.append(seq.id)         
                    not_converged=True
        
        if not_converged:
            logging.info(&#34;[iteration {}] | New calcyanin found ! :)&#34;.format(ite))        
            logging.info(&#34;[iteration {}] |  Updating GlyX3&#34;.format(ite))
            glyx3features = calcyanin_sequences.get_feature(&#34;GlyX3&#34;)
            if glyx3features:  
                glyx3 = update_hmm(glyx3features,glyx3)

            logging.info(&#34;[iteration {}] |  Updating Gly1&#34;.format(ite))
            gly1features = calcyanin_sequences.get_feature(&#34;Gly1&#34;)        
            if gly1features:
                gly1 = update_hmm(gly1features,gly1)
  
            logging.info(&#34;[iteration {}] |  Updating Gly2&#34;.format(ite))
            gly2features = calcyanin_sequences.get_feature(&#34;Gly2&#34;)        
            if gly2features:
                gly2 = update_hmm(gly2features,gly2)

            logging.info(&#34;[iteration {}] |  Updating Gly3&#34;.format(ite))
            gly3features = calcyanin_sequences.get_feature(&#34;Gly3&#34;)        
            if gly3features:
                gly3 = update_hmm(gly1features,gly3)
        
            ite += 1
            if ite == max_iteration:
                logging.warning(&#34;Max iteration reached.&#34;)
                not_converged=False
        else:
            logging.info(&#34;[iteration {}] | No new calcyanin detected.&#34;.format(ite))
            logging.info(&#34;[iteration {}] | Stop.&#34;.format(ite))
            
    return calcyanin_sequences, glyx3 , gly1, gly2, gly3    </code></pre>
</details>
</dd>
<dt id="pycalf.core.search.update_hmm"><code class="name flex">
<span>def <span class="ident">update_hmm</span></span>(<span>l_seq, hmm)</span>
</code></dt>
<dd>
<div class="desc"><p>Update Hmm by aligning sequences against it</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>l_seq</code></strong> :&ensp;<code>list</code></dt>
<dd>List of Seq object.</dd>
<dt><strong><code>hmm</code></strong> :&ensp;<code>Hmm</code></dt>
<dd>Hmm object.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>None</p>
<h2 id="return">Return</h2>
<p>Updated Hmm object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_hmm(l_seq,hmm):
    &#34;&#34;&#34;Update Hmm by aligning sequences against it
    
    Args:
        l_seq (list): List of Seq object.
        hmm (Hmm): Hmm object.
    Raises:
        None
    Return:
        Updated Hmm object.
    &#34;&#34;&#34;    
    l_digital_seq = [ s.digitize() for s in l_seq ]
    new_hmm = hmm.hmmalign( l_digital_seq )
    new_hmm.hmm = increase_glycine_weight( new_hmm,0.2 )
    return new_hmm</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pycalf.core" href="index.html">pycalf.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pycalf.core.search.decision_tree" href="#pycalf.core.search.decision_tree">decision_tree</a></code></li>
<li><code><a title="pycalf.core.search.increase_glycine_weight" href="#pycalf.core.search.increase_glycine_weight">increase_glycine_weight</a></code></li>
<li><code><a title="pycalf.core.search.make_nter_fasta" href="#pycalf.core.search.make_nter_fasta">make_nter_fasta</a></code></li>
<li><code><a title="pycalf.core.search.search" href="#pycalf.core.search.search">search</a></code></li>
<li><code><a title="pycalf.core.search.update_hmm" href="#pycalf.core.search.update_hmm">update_hmm</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>