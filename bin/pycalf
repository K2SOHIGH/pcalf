#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
        
               _ (.".) _    
              '-'/. .\'-'   
    pyCALF      ( o o )     
                 `"-"`  jgs    


        pyCALF stand for python CALcyanin Finder
        The calcyanin protein will be search and annotated within your input file(s) following three steps:
            1) the glycine triplication specific of calcyanin will be searched using a specific HMM profile.
            2) glycine zipper will be annotated individually using specifics HMM models for sequences with a glycine triplication.
            3) the N-ter extremity of sequences with a glyX3 will be annotated using blastp and known n-ter as subject database.
"""


import argparse
import os
import sys
import shutil
import logging
import multiprocessing
import tempfile
from importlib import resources

import pandas as pd

from pycalf.core import search,bioseq,biohmm
from pycalf.utils import utils 
from pycalf.utils import log


logging.basicConfig(
    format="%(asctime)s [%(threadName)-12.12s] [%(levelname)-5.5s]  %(message)s",
    level=logging.INFO,
    handlers=[]
)

DATASDIR = os.path.join(resources.files("pycalf"),"datas")

def get_args():
    parser = argparse.ArgumentParser(
        description="""pyCALF
                        
    pyCALF stand for python CALcyanin Finder

    The input fasta file will be scanned in searched of calcyanin following three steps:
    - First a specific HMM profile of the glycine triplication will be searched using HMMSEARCH.
    - Secondly, sequences with a hit in step 1 will be more precisely annotated using specifics HMM profiles for each glycine zipper.
    - Finally, a set of known N-ter will be blast against sequences with a hit in step 1.
    
    """,
        formatter_class= argparse.RawTextHelpFormatter
    )
    parser.add_argument('-f','--fasta', dest='fasta', #action="extend", nargs="+" , 
                        type=argparse.FileType('r'), default=(None if sys.stdin.isatty() else sys.stdin),
                        help='Fasta file')
                       
    parser.add_argument('-i','--input-file', dest='input', #action="extend", nargs="+" , 
                        type=argparse.FileType('r'), default=None,
                        help='Tabular file with name\t/path/to/file as lines')
                        
    # parser.add_argument('-e', dest='file_extension', type=str, default="faa.gz" , 
    #                     help='input files extension')            

    parser.add_argument('-o', dest='res_dir', type=str, required=True,
                        help='output directory')   

    parser.add_argument('--glyx3-hmm', dest='glyx3_phmm', type=str, default= DATASDIR + "/GlyX3.hmm" ,
                        help='path to GlyX3 hmm profile (default: %(default)s)" ')   
    parser.add_argument('--glyx3-msa', dest = 'glyx3_msa', 
                        default = DATASDIR + "/GlyX3.msa.fa", 
                        help='path to GlyX3 msa (default: %(default)s)')                                     

    parser.add_argument('--domz', dest='domz', type=int, default=10000,
                        help='sequence space size (default: %(default)s)"')     

    parser.add_argument('--glyx3-coverage', dest='gly3_coverage_threshold', 
                        type=float,default=0.62,
                        help="minimal coverage to be considered as a potential calcyanin (default: %(default)s)" )
    
    parser.add_argument('--glyx3-evalue', dest='gly3_evalue_threshold', 
                        type=float,default=1e-30,
                        help="hit's evalue threshold (default: %(default)s)")
                        
    parser.add_argument('--glyx3-i-evalue', dest='gly3_i_evalue_threshold', 
                        type=float,default=1,
                        help="domain's i_evalue threshold (default: %(default)s)")

    parser.add_argument('--gly1-phmm', dest = 'gly1_phmm', 
                        default = DATASDIR + "/Gly1.hmm", 
                        help='path to GlyZip1 hmm profile (default: %(default)s)')
    parser.add_argument('--gly1-msa', dest = 'gly1_msa', 
                        default = DATASDIR + "/Gly1.msa.fa", 
                        help='path to GlyZip1 msa (default: %(default)s)')

    parser.add_argument('--gly2-phmm', dest = 'gly2_phmm', 
                        default = DATASDIR + "/Gly2.hmm", 
                        help='path to GlyZip2 hmm profile (default: %(default)s)')
    parser.add_argument('--gly2-msa', dest = 'gly2_msa', 
                        default = DATASDIR + "/Gly2.msa.fa", 
                        help='path to GlyZip2 msa (default: %(default)s)')

    parser.add_argument('--gly3-phmm', dest = 'gly3_phmm', 
                        default = DATASDIR + "/Gly3.hmm", 
                        help='path to GlyZip3 hmm profile (default: %(default)s)')
    parser.add_argument('--gly3-msa', dest = 'gly3_msa', 
                        default = DATASDIR + "/Gly3.msa.fa", 
                        help='path to GlyZip3 msa (default: %(default)s)')                        

    parser.add_argument('--glyzip-i-evalue', dest='glyzip_i_evalue', 
                        type=float,default=3.6e-4,
                        help = "glyzip i-evalue threshold (default: %(default)s)" )
    parser.add_argument('--glyzip-evalue', dest='glyzip_evalue', 
                        type=float,default=1,
                        help="glyzip evalue threshold (default: %(default)s)")
    
    parser.add_argument('--blastp', default = None)

    parser.add_argument('--nterdb', dest='nterdb', 
                        default = DATASDIR + "/nterdb.ref.tsv", 
                        help='path to nterdb tabular file (default: %(default)s)')

    parser.add_argument('--nter-coverage', dest='nter_coverage', 
                        type=float,default=80,
                        help="nter minimal coverage (default: %(default)s)")

    parser.add_argument('--nter-evalue', dest='nter_evalue', 
                        type=float,default=1e-07,
                        help="nter evalue threshold (default: %(default)s)")
    
    parser.add_argument('--keep-all', action="store_true" , 
                        help="If set sequences with a partial hit against the GlyX3 profile (e.g Gly1,Gly2) will be kept")

    parser.add_argument('--log', default = None , type=str)

    parser.add_argument('-q', '--quiet', action="store_true" , help="Silent stdout logging")

    parser.add_argument('--debug', action="store_true")

    parser.add_argument('--force', action = "store_true" ,help = "overwrite output directory")

    parser.add_argument('--threads', type=int, default = multiprocessing.cpu_count(),
                        help="(default: %(default)s)")
        
    args = parser.parse_args()
    
    return args


def main():
    args = get_args()

    # Setup Logger and Handlers
    level = logging.INFO
    if args.debug:
        level = logging.DEBUG
    if not args.quiet:
        console = logging.StreamHandler()
        console.setLevel(level)
        console.setFormatter(log.CustomFormatter())
        logging.getLogger('').addHandler(
            console
        )
    if args.log:
        os.makedirs(os.path.dirname(os.path.abspath(args.log)),exist_ok=True)
        fhandler = logging.FileHandler(args.log)
        fhandler.setLevel(level)
        fhandler.setFormatter(log.CustomFormatter())
        logging.getLogger('').addHandler(
            fhandler
        )
    
    if not shutil.which("blastp"):
        logging.error("blast not found, please, considere installing it using conda install -c bioconda blast.")
        exit(-1)
    else:
        logging.debug("blastp found : {}".format(shutil.which("blastp")))

    res_dir = os.path.abspath(args.res_dir)

    if os.path.exists(res_dir):
        if args.force:
            logging.debug("{} directory have been removed because of the --force flag.".format(res_dir))
            shutil.rmtree(res_dir)            
        else:
            logging.error("Output directory already exist , Bye !")
            exit(-1)
    

    if (args.fasta and args.input) or (not args.fasta and  not args.input) :
        logging.error("Come on, please choose one between --fasta and --input-file...")
        exit(-1)

    
    console = logging.StreamHandler()
    console.setLevel(logging.INFO)
    console.setFormatter(log.CustomFormatter())
    logging.getLogger('').addHandler(
        console)
    
    logging.info("Init HMMs.")
    glyx3 = biohmm.Hmm("Glyx3",args.glyx3_phmm)
    gly1 = biohmm.Hmm("Gly1",args.gly1_phmm)
    gly2 = biohmm.Hmm("Gly2",args.gly2_phmm)
    gly3 = biohmm.Hmm("Gly3",args.gly3_phmm)
    
    logging.info("Init N-Ter DB.")
    nterdb = utils.parse_nterdb(args.nterdb)
    nterfa = tempfile.NamedTemporaryFile(mode="w+")
    for sid, nter in nterdb.items():
        nterfa.write(">{}|{}\n{}\n".format(nter[0],sid,nter[1]))
    nterfa.flush()
    
    # Initital number of sequences.
    _glyx3_nseq = glyx3.hmm.nseq
    _gly1_nseq = gly1.hmm.nseq
    _gly2_nseq = gly2.hmm.nseq
    _gly3_nseq = gly3.hmm.nseq


    fastas = []
    names = []
    # with open("test.txt") as stream:
    #     for line in stream.readlines():
    #         n,f = line.strip().split()
    #         fastas.append(f)
    #         names.append(n)
    logging.info("Start search.")
    calseq , u_glyx3 , u_gly1, u_gly2 , u_gly3 = search(
        fastas,
        names,
        glyx3,
        gly1,
        gly2,
        gly3,
        nterfa.name,        
        glyx3_evalue_threshold=1e-30,
        is_iterative=False
    )
    logging.info("The search is over.")
    
    
    logging.info("# Number of calcyanin detected : {}".format(len(calseq.sequences)))
    logging.info("# N_seqs within Glyx3 HMM : {} [+{}]".format(u_glyx3.hmm.nseq, u_glyx3.hmm.nseq -  _glyx3_nseq))
    logging.info("# N_seqs within Gly1 HMM : {} [+{}]".format(u_gly1.hmm.nseq, u_gly1.hmm.nseq - _gly1_nseq))
    logging.info("# N_seqs within Gly2 HMM : {} [+{}]".format(u_gly2.hmm.nseq, u_gly2.hmm.nseq - _gly2_nseq))
    logging.info("# N_seqs within Gly3 HMM : {} [+{}]".format(u_gly3.hmm.nseq, u_gly3.hmm.nseq - _glyx3_nseq))
    
    logging.info("Dumping HMMs.") 
    hmmdir = os.path.join(res_dir,"HMM")
    os.makedirs(hmmdir,exist_ok=True)
    u_glyx3.hmm.write(open(hmmdir + "/Glyx3.hmm","wb"))
    u_gly1.hmm.write(open(hmmdir + "/Gly1.hmm","wb"))
    u_gly2.hmm.write(open(hmmdir + "/Gly2.hmm","wb"))
    u_gly3.hmm.write(open(hmmdir + "/Gly3.hmm","wb"))

    logging.info("Dumping MSAs.")
    msadir = os.path.join(res_dir,"MSA")
    os.makedirs(msadir,exist_ok=True)
    u_glyx3.msa.write(open(msadir+"/Glyx3.msa.fa","wb"),format="afa")
    u_gly1.msa.write(open(msadir+"/Gly1.msa.fa","wb"),format="afa")
    u_gly2.msa.write(open(msadir+"/Gly2.msa.fa","wb"),format="afa")
    u_gly3.msa.write(open(msadir+"/Gly3.msa.fa","wb"),format="afa")
    
    logging.info("Dumping feature table.")
    features = calseq.to_feature_table()
    features.to_csv(res_dir + "/pycalf.features.tsv",sep="\t",header=True,index=True)
    
    logging.info("Make summary.")
    summary_datas = []
    for sequence, seq_features_df in features.groupby("sequence_id"):
        cterom = ",".join(
                        list(
                            seq_features_df[seq_features_df.feature_id.isin(["Gly1","Gly2","Gly3"]) ].sort_values("feature_start").feature_id
                            )
                )
        nterom = "".join(set(
            seq_features_df[seq_features_df.feature_id == "N-ter" ].feature_src
        ))
        
            
        summary_datas.append(
            {
                "sequence_accession":sequence,
                "flag":search.decision_tree(nterom.split("|")[0],cterom),
                "nter":nterom.split("|")[0],
                "nter_neighbor": nterom.split("|")[1],
                "cter":cterom,
                "sequence":str(calseq.get_seq_by_id(sequence).seq)
            }
        )
        pd.DataFrame(summary_datas).set_index("sequence_accession").to_csv(res_dir + "/pycalf.summary.tsv",sep="\t",index=True,header=True)

if __name__ == "__main__":
    sys.exit(main())
